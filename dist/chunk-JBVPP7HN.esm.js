import{CONFIG as e,t,o2 as r,u as o,e as n,x as a,g as i,e2 as s,n as u,o as c,i as l,a as p,O as h,p as d,realValue as f,f as m}from"./chunk-6LYSW3GO.esm.js";import{stringify as g,parse as w}from"qs";var b=class extends Error{constructor(t,r,o){const n=o?.trim()||e.PACKAGE.PREFIX.NAME,a=t.trim();super(`\n${n.startsWith("❌")?n:"❌ "+n} - ${a}`),this.originalError=r,this.name="RouterConfigError",Error.captureStackTrace&&Error.captureStackTrace(this,$)}},$=class t extends Error{constructor(r,o,n){const a=n?.trim()||e.PACKAGE.PREFIX.NAME,i=r.trim();super(`\n${a.startsWith("❌")?a:"❌ "+a} - ${i}`),this.originalError=o,this.name="RoutePropsError",Error.captureStackTrace&&Error.captureStackTrace(this,t)}},v=class{name;definition;config;wheres;bindings={};constructor(e,t,r){this.name=e,this.definition=t,this.bindings=t?.bindings??{},this.wheres=t?.wheres??{},this.config=r}get template(){const e=`${this.origin}/${this.definition?.uri}`.replace(/\/+$/,"");return r(e)?"/":e}get origin(){if(!this.config?.absolute)return"";if(this.definition?.domain){const e=this.config.url.match(/^\w+:\/\//);if(!e)throw new b('Invalid `config.url` missing protocol (e.g., `"http://"` or `"https://"`).');return`${e[0]}${this.definition.domain}${this.config.port?`:${this.config.port}`:""}`}return this.config.url}get parameterSegments(){return this.template.match(/{[^}?]+\??}/g)?.map(e=>({name:e.replace(/{|\??}/g,""),required:!/\?}$/.test(e)}))??[]}matchesUrl(e){if(!this.definition?.methods.includes("GET"))return!1;const t=this.template.replace(/[.*+$()[\]]/g,"\\$&").replace(/(\/?){([^}?]*)(\??)}/g,(e,t,r,o)=>{const n=`(?<${r}>${this.wheres[r]?.replace(/(^\^)|(\$$)/g,"")||"[^/?]+"})`;return o?`(${t}${n})?`:`${t}${n}`}).replace(/^\w+:\/\//,""),[r,o]=e.replace(/^\w+:\/\//,"").split("?"),n=new RegExp(`^${t}/?$`).exec(r)??new RegExp(`^${t}/?$`).exec(decodeURI(r));if(n){for(const e in n.groups)n.groups[e]=l(n.groups[e])?decodeURIComponent(n.groups[e]):n.groups[e];return{params:n.groups,query:w(o)}}return!1}compile(e={}){const r=this.template.replace(/{([^}?]+)(\??)}/g,(r,o,n)=>{const a=e[o];if(!n&&t(a))throw new $(`Invalid \`"${o}"\` parameter is required for route \`"${this.name}"\`.`);const i=this.wheres[o];if(i){const e=new RegExp(`^${i}$`);if(l(a)&&!e.test(a))throw new $(`Invalid \`"${o}"\` parameter \`"${a}"\` does not match required format \`${i}\` for route \`"${this.name}"\`.`)}return encodeURI(l(a)?a:"").replace(/%7C/g,"|").replace(/%25/g,"%").replace(/\$/g,"%24")});let o=r;if(this.config?.absolute&&r.includes("://")){const[e,t]=r.split("://");o=e+"://"+t.replace(/\/{2,}/g,"/")}else o=r.replace(/\/{2,}/g,"/");return"/"===o?"/":o.replace(/\/+$/,"")}},{REPO:y}=e,_=`\n\nℹ️ Learn more: \`${y.LINK}#importing-the-route-function\`.`,E=class e{absolute;url;port;defaults;routes;location;constructor(e){this.absolute=e.absolute,this.url=e.url,this.port=e.port,this.defaults=e.defaults,this.routes=e.routes,this.location=e.location}static isRouterConfigRaw(e){if(t(e))return!1;if(!u(e))throw new b(`Invalid \`route()\` the \`config\` property at (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid config object, but received: \`${a(e)}\`, with value: \`${f(e)}\`.${_}`);if(!l(e.url))throw new b(`Invalid \`route()\` parameter \`config.url\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid \`config.url\`.\n  - Parameter \`config.url\` must be of type \`string\` or \`null\`, but received: \`${a(e.url)}\`.${_}`);if(!o(e.port)&&!m(e.port))throw new b(`Invalid \`route()\` parameter \`config.port\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid \`config.port\`.\n  - Parameter \`config.port\` must be of type \`number\` or \`null\`, but received: \`${a(e.port)}\`, with value: \`${f(e.port)}\`.${_}`);if(!u(e.defaults))throw new b(`Invalid \`route()\` parameter \`config.defaults\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid \`config.defaults\`.\n  - Parameter \`config.defaults\` must be of type \`plain-object\` defaults property, but received: \`${a(e.defaults)}\`, with value: \`${f(e.defaults)}\`.${_}`);if(!u(e.routes))throw new b(`Invalid \`route()\` parameter \`config.routes\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid \`config.routes\`.\n  - Parameter \`config.routes\` must be of type \`plain-object\` routes property, but received: \`${a(e.routes)}\`, with value: \`${f(e.routes)}\`.${_}`);if("location"in e){const t=e.location;if(!u(t))throw new b(`Invalid \`route()\` parameter \`config.location\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appLocation\` is defined globally or passed as a valid \`config.location\`.\n  - Parameter \`config.location\` must be of type \`plain-object ({ host?: string | undefined; pathname?: string | undefined; search?: string | undefined; })\` of location property, but received: \`${a(t)}\`, with value: \`${f(t)}\`.${_}`);const r=t;if("host"in r&&!l(r.host)&&!d(r.host))throw new b(`Invalid \`route()\` parameter \`config.location.host\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appLocation\` is defined globally or passed as a valid \`config.location\`.\n  - Parameter \`config.location.host\` must be of type \`string\` or \`undefined\`, but received: \`${a(r.host)}\`, with value: \`${f(r.host)}\`.${_}`);if("pathname"in r&&!l(r.pathname)&&!d(r.pathname))throw new b(`Invalid \`route()\` parameter \`config.location.pathname\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appLocation\` is defined globally or passed as a valid \`config.location\`.\n  - Parameter \`config.location.pathname\` must be of type \`string\` or \`undefined\`, but received: \`${a(r.pathname)}\`, with value: \`${f(r.pathname)}\`.${_}`);if("search"in r&&!l(r.search)&&!d(r.search))throw new b(`Invalid \`route()\` parameter \`config.location.search\` property of the \`config\` (fourth parameter) detected:\n- Ensure that \`appLocation\` is defined globally or passed as a valid \`config.location\`.\n  - Parameter \`config.location.search\` must be of type \`string\` or \`undefined\`, but received: \`${a(r.search)}\`, with value: \`${f(r.search)}\`.${_}`)}return!0}static validateAndWrap(t){try{if(t instanceof e)return t;if(!this.isRouterConfigRaw(t))throw new b(`Invalid \`route()\` the \`config\` property at (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid config object, but received: \`${a(t)}\`, with value: \`${f(t)}\`.${_}`);return new e(t)}catch(e){if(e instanceof b)throw e;throw new b(`Invalid \`route()\` the \`config\` property at (fourth parameter) detected:\n- Ensure that \`appRoutes\` is defined globally or passed as a valid config object, but received: \`${a(t)}\`, with value: \`${f(t)}\`.${_}`,i(e)?e:new Error(String(e)))}}},{REPO:I,PACKAGE:R}=e,P=class extends String{_config;_route;_params={};constructor(e,i,s=!1,u){if(super(),!t(e)&&r(e))throw new $(`Invalid \`route()\`:\n- First parameter (\`name\`) must be of type a \`string\` and a non empty-string.\n- Use \`undefined\` if you don't want to provide a name.\n- Make sure to call a valid \`Router\` instance method, or you'll encounter an error. \n\nℹ️ Learn more: \`${I.LINK}#%EF%B8%8F-warning-calling-route-without-arguments\`.`);if(!o(s)&&!n(s))throw new $(`Invalid \`route()\`:\n- Third parameter (\`absolute\`) must be of type a \`boolean\` or \`undefined\`, but received: \`${a(s)}\`. \n\nℹ️ Learn more: \`${I.LINK}#absolute-url\`.`);s=!!s;const c=this.safeValidateRouterConfig(u||globalThis.appRoutes);if(this._config={...c,absolute:s},e){if(!this._config.routes[e])throw new $(`Route name \`"${e}"\` (first parameter) is not in the route list.`);this._route=new v(e,this._config.routes[e],this._config),this._params=this._parse(i)}}safeValidateRouterConfig(e){try{return E.validateAndWrap(e)}catch(e){if(e instanceof b)throw e;throw new Error(`${R.PREFIX.NAME} - Unknown error while validating \`route()\` config`,{cause:i(e)?e:void 0})}}_unresolve(e){e?this._config.absolute&&e.startsWith("/")&&(e=this._location().host+e):e=this._currentUrl();let t={};const[r,o]=Object.entries(this._config.routes).find(([r,o])=>t=new v(r,o,this._config).matchesUrl(e))||[void 0,void 0];return{name:r,...t,route:o}}_currentUrl(){const{host:e,pathname:t,search:r}=this._location();return(this._config.absolute?e+t:t.replace(this._config.url.replace(/^\w*:\/\/[^/]+/,""),"").replace(/^\/+/,"/"))+r}_location(){const{host:e="",pathname:t="",search:r=""}=s()?{}:window.location;return{host:this._config.location?.host??e,pathname:this._config.location?.pathname??t,search:this._config.location?.search??r}}_parse(e={},t=this._route){if(!u(e)&&!c(e))throw new $(`Invalid \`route()\` \`params\` property detected. \n- Second Parameter (\`params\`) must be of type \`plain-object\` or \`array\`, but received: \`${a(e)}\`.\n\nℹ️ More info: \`${I.LINK}#parameters\`.`);e??={},e=["string","number"].includes(typeof e)?[e]:e;const r=t?.parameterSegments.filter(({name:e})=>!this._config.defaults[e]);return c(e)?e=e.reduce((e,t,o)=>r?.[o]?{...e,[r[o].name]:t}:u(t)||c(t)?{...e,...t}:{...e,...l(t)?{[t]:""}:{}},{}):1===r?.length&&!e[r?.[0].name]&&(t&&e.hasOwnProperty(Object.values(t.bindings)[0])||e.hasOwnProperty("id"))&&(e={[r?.[0].name]:e}),{...this._defaults(t),...this._substituteBindings(e,t)}}_defaults(e){return e?.parameterSegments.filter(({name:e})=>this._config.defaults[e]).reduce((e,{name:t})=>({...e,[t]:this._config.defaults[t]}),{})}_substituteBindings(e,t=this._route){return Object.entries(e).reduce((e,[r,o])=>{if(!o||"object"!=typeof o||c(o)||!t?.parameterSegments.some(({name:e})=>e===r))return{...e,[r]:o};if(!o.hasOwnProperty(t.bindings[r])){if(!o.hasOwnProperty("id"))throw new $(`Object passed as \`"${r}"\` parameter is missing route model binding key \`${t.bindings[r]}\`.\n\nℹ️ More info: \`${I.LINK}#parameters\`.`);t.bindings[r]="id"}return{...e,[r]:o[t.bindings[r]]}},{})}get params(){const{params:e,query:t}=this._unresolve(),r={};for(const e in t){const o=t[e];l(o)?r[e]=o:c(o)?r[e]=o.filter(l).join(","):p(o)&&(r[e]=h(o))}return{...e,...r}}get routeParams(){return this._unresolve().params||{}}get queryParams(){return this._unresolve().query||{}}has(e){if(!l(e))throw new $(`Invalid \`route().has(...)\` parameter \`name\` detected.\n- First parameter (\`name\`) must be of type \`string\`, but received: \`${a(e)}\`.`);return this._config.routes.hasOwnProperty(e)}current(e,r={}){if(e&&!l(e))throw new $(`Invalid \`route().current(...)\` parameter \`name\` detected.\n- First parameter (\`name\`) must be of type \`string\`, but received: \`${a(e)}\`.`);if(r&&!u(r)&&!c(r))throw new $(`Invalid parameter \`params\` (\`second parameter\`) value passed to \`route().current(...)\`, expected a object or array (e.g., { foo: "bar" } or [{"foo": "bar"}]), but received: \`${a(r)}\`.\n\nℹ️ Learn more: \`${I.LINK}#routecurrent-optionally-accepts-parameters-as-its-second-argument-and-will-check-that-their-values-also-match-in-the-current-url\`.`);r??={};const{name:o,params:n,query:i,route:s}=this._unresolve();if(!e)return o;const h=l(o)&&new RegExp(`^${e.replace(/\./g,"\\.").replace(/\*/g,".*")}$`).test(o);if(t(r)||!h)return h;const f=new v(o,s,this._config);r=this._parse(r,f);const m={...n,...i};if(Object.values(r).every(e=>!e)&&!Object.values(m).some(e=>!d(e)))return!0;const g=(e,t)=>Object.entries(e).every(([e,r])=>{if(c(r)&&c(t[e])){const o=t[e];return r.every(e=>o.includes(e))}return p(r)&&p(t[e])?g(r,t[e]):t[e]==r});return g(r,m)}toString(){const e=this._route,t=this._params??={};if(!e)throw new $(`Function route() was called without a \`name\` (first parameter) but used as a \`string\`.\n- Pass a valid route name, or use route().current() to get the current route name — or route().current('dashboard') to check if it matches.\n\nℹ️ More info: \`${I.LINK}#%EF%B8%8F-warning-calling-route-without-arguments\`.`);const r=Object.keys(t).filter(t=>!e.parameterSegments.some(({name:e})=>e===t)).filter(e=>"_query"!==e).reduce((e,r)=>({...e,[r]:t[r]}),{}),o=t._query;if(!d(o)&&!u(o))throw new $(`Invalid parameter \`_query\` property of the \`params\` (second parameter) value passed to \`route()\`, expected a \`plain-object\` (e.g., { foo: "bar" }), but received: \`${a(o)}\`.\n\nℹ️ More info: \`${I.LINK}#query-parameters\`.`);return e.compile(t)+g({...r,...o},{addQueryPrefix:!0,arrayFormat:"indices",encodeValuesOnly:!0,skipNulls:!0,encoder:(e,t)=>n(e)?String(+e):t(e)})}valueOf(){return this.toString()}};function j(e,t,r=!1,o){const n=new P(e,t,r,o);return e?n.toString():n}export{b as RouterConfigError,j as route};